# Health Check Extension - V2

<!-- status autogenerated section -->
| Status        |           |
| ------------- |-----------|
| Stability     | [development]  |
| Distributions | [core], [contrib] |
| Issues        | [![Open issues](https://img.shields.io/github/issues-search/open-telemetry/opentelemetry-collector-contrib?query=is%3Aissue%20is%3Aopen%20label%3Aextension%2Fhealthcheckextensionv2%20&label=open&color=orange&logo=opentelemetry)](https://github.com/open-telemetry/opentelemetry-collector-contrib/issues?q=is%3Aopen+is%3Aissue+label%3Aextension%2Fhealthcheckextensionv2) [![Closed issues](https://img.shields.io/github/issues-search/open-telemetry/opentelemetry-collector-contrib?query=is%3Aissue%20is%3Aclosed%20label%3Aextension%2Fhealthcheckextensionv2%20&label=closed&color=blue&logo=opentelemetry)](https://github.com/open-telemetry/opentelemetry-collector-contrib/issues?q=is%3Aclosed+is%3Aissue+label%3Aextension%2Fhealthcheckextensionv2) |
| [Code Owners](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/CONTRIBUTING.md#becoming-a-code-owner)    | [@mwear](https://www.github.com/mwear) |

[development]: https://github.com/open-telemetry/opentelemetry-collector#development
[core]: https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol
[contrib]: https://github.com/open-telemetry/opentelemetry-collector-releases/tree/main/distributions/otelcol-contrib
<!-- end autogenerated section -->

Health Check Extension - V2 provides HTTP and gRPC healthcheck services. The services can be used
separately or together depending on your needs. The source of health for both services is component
status reporting, a collector feature, that allows individual components to report their health via
`StatusEvent`s. The health check extension aggregates the component `StatusEvent`s into overall
collector health and pipeline health and exposes this data through its services.

Below is a table enumerating component statuses and their meanings. These will be mapped to
appropriate status codes for the protocol.

| Status            | Meaning                                                                |
|-------------------|------------------------------------------------------------------------|
| Starting          | The component is starting.                                             |
| OK                | The component is running without issue.                                |
| RecoverableError  | The component has experienced a transient error and may recover.       |
| PermanentError    | The component has detected a condition at runtime that will need human intervention to fix. The collector will continue to run in a degraded mode. |
| FatalError        | The collector has experienced a fatal runtime error and will shutdown. |
| Stopping          | The component is in the process of shutting down.                      |
| Stopped           | The component has completed shutdown.                                  |

Adoption of status reporting by collector components is still a work in progress. As more components
report status, this extension will become more accurate and useful.

## Configuration

Below is sample configuration for both the HTTP and gRPC services.

```yaml
extensions:
  healthcheckv2:
    recovery_duration: 1m
    http:
      endpoint: "127.0.0.1:13133"
      status:
        detailed: true
        enabled: true
        path: "/health/status"
      config:
        enabled: true
        path: "/health/config"
    grpc:
      endpoint: "127.0.0.1:13132"
      transport: "tcp"
```

### Recovery Duration

Recovery duration is a setting shared by both the HTTP and gRPC services. Component status reporting
has a `RecoverableError` status to indicate a likely transient failure. The recovery duration is the
time given for a `RecoverableError` to recover before being considered unhealthy by the extension.
During the recovery duration a `RecoverableError` will be considered healthy. If the error does not
recover after the recovery duration has elapsed, it will be considered unhealthy.

## HTTP Service

### Status Endpoint

The HTTP service provides a status endpoint that can be probed for overall collector status and
per-pipeline status. The endpoint is located at `/status` by default, but can be configured using
the `http.status.path` setting. Requests to `/status` will return the overall collector status. To
probe pipeline status, pass the pipeline name as a query parameter, e.g. `/status?pipeline=traces`.
The HTTP status code returned maps to the overall collector or pipeline status, with the mapping
described below.

#### Mapping of Component Status to HTTP Status

Component statuses are aggregated into overall collector status and overall pipeline status. In each
case, you can consider the aggregated status to be the sum of its parts. The mapping from component
status to HTTP status is as follows:

| Status            | HTTP Status Code                                         |
|-------------------|----------------------------------------------------------|
| Starting          | 503 - Service Unavailable                                |
| OK                | 200 - OK                                                 |
| RecoverableError  | 200 when elapsed time < recovery duration; 500 otherwise |
| PermanentError    | 500 - Internal Server Error                              |
| FatalError        | 500 - Internal Server Error                              |
| Stopping          | 503 - Service Unavailable                                |
| Stopped           | 503 - Service Unavailable                                |


#### Response Body

The response body contains either a detailed, or non-detailed view into collector or pipeline health
in JSON format. The level of detail applies to the contents of the response body and is controlled
by the `http.status.detailed` configuration option.


##### Collector Health

The detailed response body for collector health will include the overall status for the
collector, the overall status for each pipeline in the collector, and the statuses for the
individual components in each pipeline. The non-detailed response will only contain the overall
collector health.

###### Detailed Response Example

Assuming the health check extension is configured with `http.status.endpoint` set to
`127.0.0.1:13133` a request to `http:127.0.0.1:13133/status` will have a
response body such as:

```json
{
    "start_time": "2024-01-18T17:27:12.570394-08:00",
    "healthy": true,
    "status": "StatusRecoverableError",
    "error": "rpc error: code = ResourceExhausted desc = resource exhausted",
    "status_time": "2024-01-18T17:27:32.572301-08:00",
    "components": {
        "extensions": {
            "healthy": true,
            "status": "StatusOK",
            "status_time": "2024-01-18T17:27:12.570428-08:00",
            "components": {
                "extension:healthcheckv2": {
                    "healthy": true,
                    "status": "StatusOK",
                    "status_time": "2024-01-18T17:27:12.570428-08:00"
                }
            }
        },
        "pipeline:metrics/grpc": {
            "healthy": true,
            "status": "StatusRecoverableError",
            "error": "rpc error: code = ResourceExhausted desc = resource exhausted",
            "status_time": "2024-01-18T17:27:32.572301-08:00",
            "components": {
                "exporter:otlp/staging": {
                    "healthy": true,
                    "status": "StatusRecoverableError",
                    "error": "rpc error: code = ResourceExhausted desc = resource exhausted",
                    "status_time": "2024-01-18T17:27:32.572301-08:00"
                },
                "processor:batch": {
                    "healthy": true,
                    "status": "StatusOK",
                    "status_time": "2024-01-18T17:27:12.571132-08:00"
                },
                "receiver:otlp": {
                    "healthy": true,
                    "status": "StatusOK",
                    "status_time": "2024-01-18T17:27:12.571576-08:00"
                }
            }
        },
        "pipeline:traces/http": {
            "healthy": true,
            "status": "StatusOK",
            "status_time": "2024-01-18T17:27:12.571625-08:00",
            "components": {
                "exporter:otlphttp/staging": {
                    "healthy": true,
                    "status": "StatusOK",
                    "status_time": "2024-01-18T17:27:12.571615-08:00"
                },
                "processor:batch": {
                    "healthy": true,
                    "status": "StatusOK",
                    "status_time": "2024-01-18T17:27:12.571621-08:00"
                },
                "receiver:otlp": {
                    "healthy": true,
                    "status": "StatusOK",
                    "status_time": "2024-01-18T17:27:12.571625-08:00"
                }
            }
        }
    }
}
```

Note the following based on this response:
- The overall status is `StatusRecoverableError` but the status healthy because
  the recovery duration has not yet passed.
- `pipeline:metrics/grpc` has a matching status, as does `exporter:otlp/staging`. This implicates
  the exporter as the root cause for the pipeline and overall collector status.
- `pipeline:traces/http` is completely healthy.

###### Non-detailed Response example

If the same request is made to a collector with `http.status.detailed` to `false`, you will only get
the overall status. The pipeline and component level statuses will be omitted.

```json
{
    "start_time": "2024-01-18T17:39:15.87324-08:00",
    "healthy": true,
    "status": "StatusRecoverableError",
    "error": "rpc error: code = ResourceExhausted desc = resource exhausted",
    "status_time": "2024-01-18T17:39:35.875024-08:00"
}
```

###### Pipeline Health

The detailed response body for pipeline health is essentially a zoomed in version of the detailed
collector response. It contains the overall status for the pipeline and the statuses of the
individual components. The non-detailed response body contains only the overall status for the
pipeline.

###### Detailed Response Example

Assuming the health check extension is configured with `http.status.endpoint` set to
`127.0.0.1:13133` a request to `http:127.0.0.1:13133/status?pipeline=traces/http` will have a
response body such as:


```json
{
    "start_time": "2024-01-18T17:27:12.570394-08:00",
    "healthy": true,
    "status": "StatusOK",
    "status_time": "2024-01-18T17:27:12.571625-08:00",
    "components": {
        "exporter:otlphttp/staging": {
            "healthy": true,
            "status": "StatusOK",
            "status_time": "2024-01-18T17:27:12.571615-08:00"
        },
        "processor:batch": {
            "healthy": true,
            "status": "StatusOK",
            "status_time": "2024-01-18T17:27:12.571621-08:00"
        },
        "receiver:otlp": {
            "healthy": true,
            "status": "StatusOK",
            "status_time": "2024-01-18T17:27:12.571625-08:00"
        }
    }
}
```

###### Non-detailed Response example

If the same request is made to a collector with `http.status.detailed` to `false`, you will only get
the overall status. The component level statuses will be omitted.

```json
{
    "start_time": "2024-01-18T17:39:15.87324-08:00",
    "healthy": true,
    "status": "StatusOK",
    "status_time": "2024-01-18T17:39:15.874236-08:00"
}
```

### Collector Config Endpoint

The HTTP service optionally exposes an endpoint that provides the collector configuration. Note,
the configuration returned is unfiltered and may contain sensitive information. As such, the
configuration is disabled by default. Enable it using the `http.config.enabled` setting. By
default the path will be `/config`, but it can be changed using the `http.config.path` setting.

### gRPC Service

The health check extension provides an implementation of the [grpc_health_v1 service]. The service
was chosen for compatibility with existing gRPC health checks, however, it does not provide the
additional detail available with the HTTP service. Additionally, the gRPC service has a less
nuanced view of the world with only two reportable statuses: `HealthCheckResponse_SERVING` and
`HealthCheckResponse_NOT_SERVING`.

#### Mapping of ComponentStatus to HealthCheckResponse_ServingStatus

The HTTP and gRCP services use the same method of component status aggregation to derive
overall collector health and pipeline health from individual status events. The component
statuses map to the following `HealthCheckResponse_ServingStatus`es.

| Status            | HealthCheckResponse_ServingStatus                                  |
|-------------------|--------------------------------------------------------------------|
| Starting          | HealthCheckResponse_NOT_SERVING                                    |
| OK                | HealthCheckResponse_SERVING                                        |
| RecoverableError  | HealthCheckResponse_SERVING when elapsed time < recovery duration; HealthCheckResponse_NOT_SERVING otherwise |
| PermanentError    | HealthCheckResponse_NOT_SERVING                                    |
| FatalError        | HealthCheckResponse_NOT_SERVING                                    |
| Stopping          | HealthCheckResponse_NOT_SERVING                                    |
| Stopped           | HealthCheckResponse_NOT_SERVING                                    |


#### HealthCheckRequest

The gRPC service exposes two RPCs: `Check` and `Watch` (more about those below). Each takes a
`HealthCheckRequest` argument. The `HealthCheckRequest` message is defined as:

```protobuf
message HealthCheckRequest {
  string service = 1;
}
```

To query for overall collector health, use the empty string `""` as the `service` name. To query for
pipeline health, use the pipeline name as the `service`.

#### Check RPC

The `Check` RPC is defined as:

```protobuf
rpc Check(HealthCheckRequest) returns (HealthCheckResponse)
```

If the service is unknown the RPC will return an error with status `NotFound`. Otherwise it will
return a `HealthCheckResponse` with the serving status as mapped in the table above.

#### Watch Streaming RPC

The `Watch` RPC is defined as:

```protobuf
rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse)
```

The `Watch` RPC will initiate a stream for the given `service`. If the service is known at the time
the RPC is made, its current status will be sent and changes in status will be sent thereafter. If
the service is unknown, a response with a status of `HealthCheckResponse_SERVICE_UNKNOWN`` will be
sent. The stream will remain open, and if and when the service starts reporting, its status will
begin streaming.

### Future

There are plans to provide the ability to export status events as OTLP logs adhering to the event
semantic conventions.

[grpc_health_v1 service]: https://github.com/grpc/grpc-proto/blob/master/grpc/health/v1/health.proto